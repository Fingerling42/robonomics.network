---
title: Тестирование Neon EVM с использованием смарт-контрактов Robonomics
date: 2022-10-03
published: true
locale: 'ru'
tags: ['Robonomics in Ethereum', 'Collaborations', 'Smart Contracts', 'Neon']
cover_image: /blog/images/testing-neon-with-robonomics/blog_cover_neon_multi-agent.jpg
description: "Целью этих тестов была проверка готовности платформы Neon к переходу на стадию продакшена с использованием смарт-контрактов Robonomics, которые позволяют кибер-физическим системам (роботам) совершать технико-экономические транзакции."
abstract: ""
---

## Кратко

Целью этих тестов была проверка готовности платформы [Neon](https://neon-labs.org/) к переходу на стадию продакшена с использованием смарт-контрактов Robonomics, которые позволяют кибер-физическим системам (роботам) совершать технико-экономические транзакции.

В сети Robonomics взаимодействие устанавливается между двумя сторонами: Promisee — тот, кто заказывает услугу, отправляет описание технического задания и переводит средства на её выполнение; Promisor — тот, кто выполняет услугу. Был протестирован типовой сценарий, при котором между Promisee и Promisor заключается контракт обязательства — далее следовала валидация выполненной работы третьей стороной и выплата комиссии узлу, сопровождавшему контракт между сторонами.

В этом примере использовалась симуляция работы роботизированной руки, которой было предложено выполнить последовательность действий. Тесты прошли успешно.

## Область и цели тестирования

Инженеры [Multi-Agent Systems](https://multi-agent.io/) уже несколько лет работают с [Robonomics Network](https://robonomics.network/). Первая реализация Robonomics Network была создана для сети Ethereum. Это набор смарт-контрактов для коммуникации между машинами.

Ядром Robonomics Network является контракт [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol), смарт-контракт, который воспроизводит типовые отношения между заказчиком услуги (Promisee) и исполнителем услуги (Promisor), а также включает технические и экономические параметры сделки между ними. Сторонами могут быть как автономный агент и человек (взаимодействие человек-машина), так и два автономных агента (взаимодействие машина-машина). Promisee и Promisor передают сообщения с параметрамиих технико-экономическая сделка, а затем заключение сделки обеспечивается специальным узлом — Провайдером, который ищет совпадения этих параметров. Провайдеры управляются [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), который является специальным смарт-контрактом, выполняющим транзакцию, когда провайдер устанавливает рыночное совпадение между сторонами.

Существует три сценария, в которых может происходить исполнение обязательства:

1. Простое обязательство (без проверки конечного результата и без выплаты комиссии узлам Провайдера)
2. Обязательство с выплатой комиссии Провайдеру
3. Обязательство с комиссией Провайдеру и валидацией результатов с помощью третьей стороны — наблюдающей сети.

Цель этого теста — проверить самый сложный, третий сценарий Robonomics на платформе Neon EVM.

## Описание тестовых сценариев

По мере развития промышленных зон и инфраструктуры современных городов весьма вероятно появление полностью автоматизированных предприятий и сервисов, управляемых кибер-физическими системами (CPS), которые предоставляют свои услуги в качестве автономных агентов. В связи с этим можно также ожидать формирования сетей автономных CPS для повышения скорости и качества коммуникации в процессе производства и предоставления услуг.

Чтобы в полной мере использовать возможности смарт-контрактов, был выбран сценарий взаимодействия двух автономных экономических агентов. Рассмотрим жизненный цикл обязательства в сети Robonomics:

![Liability Life Cycle](/blog/images/testing-neon-with-robonomics/step-by-step-3.jpg)

На рисунке выше показано, что провайдер сети Robonomics вызывает контракт Lighthouse, который, в свою очередь, вызывает [фабрику контрактов](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) для создания контракта Liability. Контракт Liability содержит данные о сделке, такие как техническое задание, оплата за услугу, адрес валидатора и срок исполнения.

Чтобы узнать больше о возможных сценариях использования Robonomics, ознакомьтесь со страницей Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer)!

Для воспроизведения всей инфраструктуры Robonomics в сети Neon мы реализуем сценарий запуска робота через контракт Liabilityпохоже на этот [пример](https://wiki.robonomics.network/docs/en/kuka/). Если скрипт можно повторить, то все функции будут работать.

## Результаты

Исходный код контрактов Robonomics доступен [здесь](https://github.com/airalab/robonomics_contracts).
Контракты используют множество функций Ethereum VM, включая:

- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) токен
- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)
- Собственный контракт для [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)
- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) для контрактов
- Различные модификаторы и роли в контрактах

Адреса контрактов в сети Neon devnet https://devnet.neonevm.org

| Имя контракта  | Адрес                                      |
|----------------|--------------------------------------------|
| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |
| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |
| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |
| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |
| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |
| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |
| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |
| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |
| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |

[Исходный код](https://github.com/Multi-Agent-io/neon-kuka-demo) для сценария

## Изменения, внесённые в оригинальные контракты

Контракты написаны для Solidity 0.5.0. Поэтому при развертывании и использовании контрактов изменений не требовалось.

## Тестовый рабочий процесс

В целом, тест состоит из отправки соответствующих сообщений от одного агента другому.

Далее Promisor находит новый контракт обязательства в сети и начинает его выполнять. По завершении работы отправляется сообщение с результатом, который затем записывается в контракт.

Пошаговые инструкции по запуску находятся в [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)

## Подробные результаты тестирования

Скринкаст процесса

<YouTube id="https://youtu.be/fYJVF7KrNnI" posterQuality="max" />

![Liability](/blog/images/testing-neon-with-robonomics/liability.jpg)

Когда начинается симуляция, создаётся сообщение предложения, и от Promisee приходит сообщение спроса, после чего создаётся контракт обязательства с помощью функции createLiability контракта Lighthouse. С помощью контракта XRT токены переводятся с адреса Promisee на адрес контракта обязательства.

После того как новый контракт обязательства был обнаружен в Neon devnet, агент начинает работу. Результат работы (телеметрия) записывается в файл и отправляется в IPFS, хеш из файла сохраняется как результат.

После завершения работы контракт обязательства финализируется с помощью функции finalizeLiability() контракта Lighthouse, и токены переводятся с адреса обязательства на адреса Promisor и Validator.

Успешное выполнение симуляции показало, что все контракты работали корректно и платформа Neon функционирует.

## Недостатки платформы Neon

### Truffle завершает работу с ошибкой, если не получает ответ от сети

В процессе развертывания контрактов выяснилось, что прокси не всегда возвращает ответ вовремя, из-за чего Truffle завершает работу с ошибкой:

<RbCode>

```sh
TypeError: Cannot read properties of null (reading 'from')                                    
    at Web3InterfaceAdapter.(<anonymous>) (/usr/lib/node_modules/truffle/build/webpack:/packages
/interface-adapter/dist/adapter/web3/index.js:71:1)                                           
    at Generator.next (<anonymous>)                                                          
    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist
/adapter/web3/index.js:5:43)                                                                  
    at runMicrotasks (<anonymous>)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
Truffle v5.5.23 (core: 5.5.23)
Node v16.14.0
```
</RbCode>

Не удалось найти связь между условиями теста и возникновением ошибки, но, скорее всего, Neon EVM не может отправить квитанцию о транзакции, а Truffle не может обработать Null-ответ.

Если добавить таймаут и повторную попытку здесь [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), то деплой должен пройти без ошибок.

### Нет WS/WSS Endpoint

В отличие от Ethereum, у Neon EVM нет WS/WSS endpoint, что делает невозможным подписку на события из сети. Поэтому во время тестирования мы отслеживали события вручную.

### Нет Имён Событий

Neon EVM возвращает довольно скудные описания событий после транзакции, например:

<RbCode>

```sh
 events: {
    '0': {
      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',
      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',
      transactionLogIndex: '0x1',
      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',
      blockNumber: 156073183,
      transactionIndex: 0,
      logIndex: 1,
      id: 'log_e51e2f9f',
      returnValues: Result {},
      event: undefined,
      signature: null,
      raw:[Object]
    },
...
```
</RbCode>

Вместо 0, 1 и т.д. мы ожидали увидеть именованные события.

## Заключение

С использованием платформы Neon EVM был успешно протестирован сценарий, в котором заключается договор обязательства между Обещателем и Обещанным с последующей валидацией результата выполненной работы третьей стороной. Дополнительно участвовал Провайдер, который проверял совпадение спроса и предложения между сторонами и получал комиссию за эту работу.

В демонстрации использовалась симуляция работы роботизированной руки, которую наняли для выполнения последовательности действий. В результате работы робот отправил файл с телеметрией, полученной во время выполнения задания.

Несмотря на некоторые особенности работы сети, в итоге все участвующие контракты показали свою работоспособность в среде Neon.